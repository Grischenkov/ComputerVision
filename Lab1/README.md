# Лабораторная работа №1. Дилатация изображения

## Задание 
Задан примитив размера 3 на 3. На вход поступает изображение, программа отрисовывает окно, в которое выводится либо исходное изображение после бинаризации, либо после дилатации (переключение по нажатию клавиши).

Базовый алгоритм (дилатация), используемый в программе, необходимо реализовать в 3 вариантах:
* с использованием встроенных функций библиотеки OpenCV,
* нативно на Python,
* с использованием Numba.

## Теория
_Дилатация (морфологическое расширение)_ – свертка изображения или выделенной области изображения с некоторым ядром. Ядро может иметь произвольную форму и размер. В ядре выделяется единственная ведущая позиция, которая совмещается с текущим пикселем при вычислении свертки.

Дилатация увеличивает область изображения, расширяя его пиксели и тем самым способствуя объединению областей изображения, которые были разделены шумом и тд.

Изображение после дилатации становится светлее и слегка размытым. То есть темные детали ослабляются или вообще исчезают. Это зависит от соотношения их размеров и яркостей с заданными параметрами фильтра.

![Alt text](images/description.jpg?raw=true "Дилатация")

## Реализация
Этапы работы программы:
1. Выбор реализации алгоритма.
2. Загрузка видео.
3. Обработка видео.

Переключение режима работы (дилатация/бинаризация) происходит по нажатию клавиши 'w'.

Среднее время обработки кадров вычисляется только для режима дилатации.

## Результаты
Результат дилатации бинарных и цветных изображений:
![Alt text](images/sample_1.png?raw=true "Дилатация")

Временные характеристики работы алгоритмов:
| Алгоритм |  Время работы   |
| ------   | ------          |
| OpenCV   | 0.0017814879 с  |
| Python   | 59.6635466814 с |
| Numba    | 0.0684318837 c  |

## Выводы
В результате проделанной работы была реализована программа по сравнению трех реализаций алгоритма дилатации.

* Наилучший результат показала реализация с помощью функций библиотеки OpenCV. 
* На втором месте по скорости - JIT компиляция, поскольку она отлично справляется с циклами и повышает эффективность алгоритма (прирост производительности относительно Python примерно в 900 раз). 
* На третьем месте по скорости - нативный Python, поскольку циклы на Python неэффективны в чистом виде.

## Список используемых источников
* https://intuit.ru/studies/courses/10621/1105/lecture/17989?page=4
* https://docs.opencv.org/3.4/d4/d76/tutorial_js_morphological_ops.html
* https://docs.opencv.org/4.x/d7/d4d/tutorial_py_thresholding.html